`vig`
===

## 不一样的框架

##### by [calidion](https://github.com/calidion)

----

vig是什么？
===
1.  一个新的框架
2.  简单，轻量，高速
3.  基于Web业务本身
4.  关注Web业务的细节
5.  非传统MVC框架
	1)	无具体的Controller
	2)	Model和View可选
6. 基于Node.js

---

为什么要开发vig
===

1. 目前似乎没有纯做Web业务的框架
2. 减少重复的处理Web常规业务的代码
3. 找出更多的常规Web业务场景
4. 减少开发时间
5. 对传统MVC框架的不满

---

vig 1.0 包含那些新的内容？
===
1. 固定了很多中间件功能及位置，减少类似于express.use这样的中间件的选择
2. 将常用的Web业务固定化.比如对于post，默认支持form表单解析；比如默认的文件上传功能等。
3. 纠正koa中间件中错误方式，实现无回调函数的async/await中间件，以及回归中间件的线性本质
4. 提供了组件部分属性可承继的功能，从而实现了层次化组织HTTP请求的能力

---

vig 1.0 包含那些新的内容？（二）
===
5. 默认除事件（event）外，所有的调用函数都是支持async/await异步调用的
6. 支持WebSocket，并提供了自动的Session功能。让游戏，聊天室的编写更加的方便。
7. 为几乎所有中间件与请求添加了scope对象，让系统可以更加方便的获取系统的配置与设置，而无需要引用相对的文件。
8. 模板的分布式组合

---

如何理解vig?
===

可以将vig理解为express++

1. 几乎兼容所有的express中间件
2. 支持与express协同开发
3. 增强了async/await
4. 增强了web逻辑的处理能力

---

vig对web的看法
===

vig将web看成是一条直线。在这个直线上有很多处理点。而vig做的事情就是将这些点提出来，并且将这些点细化。所以我们可以将这个模型称之为web请求直线,简称***Web直线***。

也就是说vig是基于HTTP的请求直线来开发的框架。

它的起点是req请求到达服务器，终点是处理完成后通过res发送出去。

---

## web直线

1. 最简单的表示
```
req => process => res
```
2. 更加详细，但是并不全面的表示

```
req => middlewares(parser, authorization, 
security / policy, conditional entrance,
valiator) 
=> router => product logic => output => res

```
3. process的内容是可大可小的，vig将优先做好最核心最常用的部分

---

## vig关注的点

***Web直线***上除`产品逻辑(product logic)`外所有Web技术问题。

也就是说vig要完全区分开`web逻辑(web logic)`与`产品逻辑(product logic)`。

同时要为编写`产品逻辑`提供很好的技术基础。

---

## 深化与突破MVC

vig对mvc有如下的看法：

1. mvc是一个简单的模型，现实场景远比MVC复杂
2. 认为mvc三者都是可选的，并不需要完备
3. 同时mvc三者都是可拆解的，并且vig主要是拆解了C
4. 认为MVC是递归的，所以C里仍可以包括有完整的MVC体系

基于以上的几点看法，才会了vig对MVC的突破。

---

## 消除回调地狱，全面async/await化

在0.8发布时，vig并没有马上提供async/await化的支持。

一方面是时间不允分，也有与旧代码兼容的原因。

0.9版本开始，vig就全面转向了async/await。

所有的中间件，路由都通过async/await来实现异步。

1.0版本开始，vig提供了scope，让系统的变量与中间件都可以很好的通过scope来被访问，同时scope提供了依赖注入的能力。

---

## 版本升级

在vig的版本管理上，vig否定了semver的理想主义原则。

采用了[effective versioning](https://github.com/calidion/effective-versioning)的态度。即：

1. 不鼓励升级
2. 不做自动升级
3. 小版本，表示错误修正或者小调整，建议努力保持兼容，但不做兼容保证
4. 大版本表示架构的变动或者属性的大规模升级，但是仍可以保持兼容性

> Effective Versioning完全否定了大小版本基于兼容性的特点。

---

## 包管理

由于Semver的理论的错误，导致了npm在处理包上存在重大错误。
经常会导致包不稳定，并且包作者无法控制。
因此谷歌等多家公司联合起来推出了yarn这个包管理工具，试图将包的依赖固定，从而保证包的稳定性，从而可以在产生环境下保证代码的迁移不变性。

因此vig推荐使用yarn包管理工具来管理vig项目。

npm5对这类问题进行了修复，但是考虑到不同node使用的npm版本可能不同，所以直接使用yarn更加的简单，不容易混淆。

---

## URL为中心的框架，面向微服务的架构

### 传统MVC框架的问题

#### Controller的控制粒度过大取

login（get) 获取登录页面与login(post)进行登录操作通常混在一起编写。对于get我们并不需要数据检验，但是对于post我们是需要数据检验的。而写在一起代码就显得混乱。

#### 模块化能力差

将GET/POST事件放在一个方法处理，不方便业务逻辑的分离，模板化水平低

#### 耦合度高

将GET/POST事件进行了耦合，代码的独立性降低，耦合度增加。


---

## URL为中心的框架，面向微服务的架构

### vig的解决方案

与传统的MVC框架不同，vig里的代码的组织是基于URL的，或者说是基于业务/逻辑单元的。

在vig里，处理是基于URL来组织起来的。通过URL将业务分割成独立的单元。

所以/user/login对应不同的HTTP方法，处理是完全分开的。

所以每个请求的代码都很短，并且处理的方式完全不同，get方法时不会加载中间件，会非常快。post时会自动加载form处理，加载validator进行验证，所以可以完美的解决传统MVC框架存在的问题。

除了解决传统MVC框架的问题外，vig还有很多其它的可能性。

---

## 明确的中间件排序

由于我们之前讲到了Web直线，而在直线上的任何两个点都是有方向性的。因些我们的很多中间件其实也是有序列。
所以vig的工作就是找到这些顺序，并且按正确的方式排列出来。

一个简单的例子就是，你必须将post过来的body解析后，你才能对body的数据进行校验。

所以body parser 一定在validator之前。
但是在写vig时，你就不需要考虑他们的顺序，因为vig都帮你处理好了。

---

## scope建立处理与系统的桥梁

通常，我们获取系统的配置，请求过来的数据，检验的结果等数据都是需要自己手动写的。

但是在vig里，scope会很好的帮助你完成这些工作。

scope会提供上级以及当前的处理URL程序的所有配置信息，经过校验的数据，分页的信息等。

系统的模型类的信息。

scope是路由(Router)处理中最核心的对象。

scope对象是一种***弱水共享***（即弱水三行， 我只取一瓢）。
	
本身scope里有很多内容，但是router处理里，只需要取出相应的需要的内容进行处理即可。

---
## scope获取系统内容
const {models, errors，configs} = scope
即可获得系统定义的模型与错误信息
models: 整个系统的模型
errors: 整个系统的错误与当前组件错误的整合结果
configs: 整个系统的配置与当前组件的配置的整合结果

---

## 支持npm包级别模块化

前面讲到vig是按处理逻辑来划分模块的，这样的好处是能将模块直接打包成npm包。
然后在使用到的时候直接包含进来，非常有利于团队的协作开发与集成测试。

---

## API错误的统一处理

vig基于errable提供了统一的API错误机制。

1. 基于errorable
2. 包括基本的错误代码
3. 方便的自定义机制

---


## 层次化的模板管理

---

# 高效

1. 基础执行高效
	
    “Hello World"程序的效率约等于基础框架
    
2. 单个请求高效，灵活

	单个请求所经过的路由
    
3. 整体上高效


---


## 分布+组装的模板

## 适合的场景

1. Web网站快速开发
2. 实时应用，如游戏与聊天室，股票行情等
3. 网站与实时应用在用户上具高度一致性的项目


## vig的调试

1. 支持debug模块，但尚不完善
2. `DEBUG=vig:*` 即可开启调试模式




<!-- footer: This is a footer -->


